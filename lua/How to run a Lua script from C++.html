原文出处：
http://www.acamara.es/blog/2012/08/running-a-lua-5-2-script-from-c/

译文如下：
Lua is an extensible programming language to extend other programming languages — called host languages. This is extremely powerful for many reasons. My favorite is that
It allows to change the behavior of a compiled program without having to recompile it.
Unfortunately, I have not found many tutorials on the net regarding the basic embedding of Lua 5.2 — which is a bit different from 5.1, 5.0 and 4.X — in C++, including these topics:
Lua 是一个胶水语言，可以很方便的去扩展其它宿主语言。说她强大是有很多原因的，而我最喜爱的莫过于她允许无需重新编译即可改变一个程序的执行逻辑。
不幸的是，我发现网上很少有关于lua 5.2的混编教程，而lua 5.2与c++的混编与lua 5.1,lua 5.0,还有lua 4.x是有些差别的，其中包括如下主题：
How to run a Lua script from C++
How to pass information from Lua to C++ and vice-versa
How to call C++ functions from Lua
How to dynamically link libraries of C functions to Lua
How to implement a simple class in Lua
How to pass objects from C++ to Lua and vice-versa

1，c++如何调用Lua 脚本
2，c++与Lua之间如何互传信息
3，Lua如何调用c++
4，Lua如何动态连接c函数库
5，Lua如何实现面向对象
6，如何在c++和Lua之间互传对象

This is just the transcription of my personal notes about the first topic. Hopefully, in the future I will also transcript the notes I have taken regarding the rest of topics. Most of the information has been taken from the Lua Wiki sample code and updated (if needed) using the Lua 5.2 reference manual.
此文仅是我个人关于上述第一个主题的一些看法。关于后续主题，我将稍后论述。
文中相关代码引用自:
Lua Wiki      http://lua-users.org/wiki/SampleCode
Lua 5.2 手册   http://www.lua.org/manual/5.2/manual.html
中文手册       http://www.photoneray.com/Lua-5.2-Reference-Manual-ZH_CN/#lua_settop

I am using Lua version 5.2.1 downloaded from its official page and compiled in Microsoft Visual C++ Express 2010. I am not covering the compilation process of Lua — it is well documented online — nor the meaning of the Lua code beyond its basic behavior.
我所使用的Lua为官方版本5.2.1,通过Microsoft Visual C++ Express 2010进行编译。Lua的编译过程，以及Lua的语法细节，已超出本文范畴，具体详情请参考Lua在线文档。
Running a Lua script from C++
c++调用Lua脚本
This is the most basic action you can do with embedded Lua in a C++ program. Imagine you have the typical Hello World program in Lua, something like
这是你能用c++和Lua混编做的最简单的事儿。假如你的Lua脚本的如下：

-- Simple Hello World Lua program
print('Hello World!')

and you want to run it from inside a simple C++ program. The procedure is the following:
然后，你想从一个简单的c++程序里面调用它。具体步骤如下：
Create a Lua state — like a Lua virtual machine in which our script will be running.
Load the needed Lua libraries to run the script.
Run the Lua script.
Close the Lua state.
1，创建Lua状态机--你可以认为是一个运行Lua脚本的虚拟机
2，加载所需要的Lua库
3，运行Lua脚本
4，关闭Lua状态机

The project must link to the Lua libraries, that have been compiled previously, and must have access to the Lua header directory, since we will be including the <lua.hpp> file. We also assume that the C++ executable is generated in the same directory as the Lua script and that the script is called <helloworld.lua>.
因为我们包含了Lua的头文件，故项目必须能够连接预先编译好的Lua库文件，Lua的相关头文件也必须能被项目访问。
The full code will look like:
完整代码如下所示：
#include <lua.hpp>

int main(int argc, char* argv[])
{
    // create new Lua state
    lua_State *lua_state;
    lua_state = luaL_newstate();

    // load Lua libraries
    static const luaL_Reg lualibs[] =
    {
        { "base", luaopen_base },
        { NULL, NULL}
    };

    const luaL_Reg *lib = lualibs;
    for(; lib->func != NULL; lib++)
    {
        lib->func(lua_state);
        lua_settop(lua_state, 0);
    }

    // run the Lua script
    luaL_dofile(lua_state, "helloworld.lua");

    // close the Lua state
    lua_close(lua_state);
}
The output of the program is just what we expect:
程序的输出正如我们所预料的那样：


Detailed explanation
细节分析
Let’s check the code by pieces. The first piece is to create the new Lua state:
让我们详细的剖析相关代码。第一段代码是用来创建Lua状态机。
    // create new Lua state
    lua_State *lua_state;
    lua_state = luaL_newstate();
There is no mystery to it. The only step is to store in a pointer the newly created Lua state returned by luaL_newstate(). Afterwards we can use that pointer to refer to the Lua state.
代码的意图很明显。唯一要做的就是把通过luaL_newstate()函数创建的Lua状态机的地址保存到一个指针。然后我们就可以通过指针来使用状态机。
The second piece is to load the needed libraries. This is a bit more tricky. Every Lua library — even the ones generated by yourself — are opened by a C++ function and stored in the Lua state as a global table with a given name. Therefore, our first step is to define the name and opening functions for the desired libraries. Since our hello-world script is so simple, only the base Lua library is needed. We define “base” as the name of the base library, which is opened by the luaopen_base() function.
第二段代码的作用是加载所需的库文件。这部分有点难以理解。每个Lua库，包括你自己生成的，都是被c++打开，并保存到Lua状态机的。
    // load Lua libraries
    static const luaL_Reg lualibs[] =
    {
        { "base", luaopen_base },
        { NULL, NULL}
    };
Then, we load every selected library by calling its loading function with our Lua state pointer. The lua_settop() sentence just ensures that we discard any variables that may be populated into the Lua stack.
然后，我们把Lua状态机的指针当做参数传给库的加载函数来加载每个库。lua_settop（）函数的的调用是为了确保清除Lua堆栈的所有变量。
    const luaL_Reg *lib = lualibs;
    for(; lib->func != NULL; lib++)
    {
        lib->func(lua_state);
        lua_settop(lua_state, 0);
    }
The third piece is to run our script which is self-explained in this code:
第三段代码的作用是运行我们的Lua脚本。
    // run the Lua script
    luaL_dofile(lua_state, "helloworld.lua");
You only have to provide the Lua state in which you want the script running and the filename — with full path if it is not in the same directory of your C++ executable — of the Lua script.
你唯一需要提供的就是状态机指针和脚本名称，如果脚本跟c++可执行文件不再同一目录，就加上完整路径。

The last piece is to close the Lua state:
最后一段代码的作用是关闭状态机。
    // close the Lua state
    lua_close(lua_state);
This will remove any memory used by the Lua state — except for some tables in rare cases.
这会清空状态机所使用的所有内存，除非一些罕见的情况。
And that is it!
以上。
That is the one of the most simple examples of embedding Lua into C++ programs. Stay tuned for further, more complicated examples. Read the next tutorial!
这是最简单的c++和Lua混编。稍后会奉上更加复杂的使用案例，敬请期待。
